#! /bin/bash

function dot() {
    local CONFIG_FILE="${BASH_SOURCE%/*}/yml/dot.yml"
    function dot_help(){
        echo "
DESCRIPTION:
    Navigate in directory stack, and open and execute files.

USAGE:
    dot [option] [argument]

OPTIONS:
    n, nav [dir] ............ Navigate to the specified directory and list contents
           [file] ........... Open the specified file according to its extension
           '-', '...' ....... Go back to the previous directory in the stack
           '..' ............. Navigate to parent directory
    h, home [user] .......... Navigate to the user's home directory
    a, alias ................ Navigate or open alias directory or file
    s, src, source .......... Source a file or all files in a directory
    x, exec.................. Execute the file according to its extension
    p, preview .............. Open fzf in preview mode for the given directory
    d, delete ............... Safely delete the given entry
    l, ls, list ............. List files and directories
    lf, lsf, list-files ..... List files
    ld, lsd, list-dirs ...... List dirs
    rm, remove .............. Permanently remove the given entry
    rn, rename .............. Rename the given entry
    rc, rc .................. Open some rc file with given alias
    mf, mkf, make-file ...... Create files
    md, mkd, make-dir ....... Create directories
    t, template ............. Instantiate a template
    "
    }

    function dot_ls(){
        if [[ "$1" == "h" ]]; then
            if [[ -n "$DOT_LS_HIDDEN" ]]; then
                shift 1
                "$DOT_LS_HIDDEN" "$@"
            else
                ls -a --color=auto --group-directories-first
            fi
        else
            if [[ -n "$DOT_LS" ]]; then
                "$DOT_LS" "$@"
            else
                ls --color=auto --group-directories-first
            fi  
        fi
    }

    function dot_cd() {
        if [[ -n "$DOT_CD" ]]; then
            "$DOT_CD" "$@"
        else
            pushd $1 > /dev/null 2>&1
        fi        
    }

    function dot_open() {
        local ext=${1##*.}
        local default_cmd=$(yq e '.open.default // "xdg-open"' $CONFIG_FILE)
        local cmd=$(yq e ".open.${ext} // \"$default_cmd\"" $CONFIG_FILE)
        eval "$cmd $1"
    }

    function dot_nav(){
        if [[ "$1" == "-" || "$1" == "..." ]]; then
            shift 1
            popd > /dev/null 2>&1
            dot_ls "$@"
        elif [[ "$1" == ".." ]]; then
            cd ..
        elif [[ -d "$1" ]]; then
            dot_cd "$1"
            dot_ls
        elif [[ -f "$1" ]]; then
            dot_open "$1"
        else
            dot_ls
        fi
    }

    function dot_exec() {
        local ext=${1##*.}
        local cmd=$(yq e ".exec.${ext} $CONFIG_FILE")
        if [[ -n "$cmd" ]]; then
            eval "$cmd "$1""
        fi
    }

    function dot_home(){
        if [[ -z "$1" ]]; then
            cd $HOME
        else
            mapfile -t USERS < <(users)
            if [[ "${USERS[@]}" =~ "$1" ]]; then
                cd /home/$1
            else
                echo "error: user $1 not exists."
                return 1
            fi
        fi
    }

    function dot_trash(){
        TRASH_DIR=$(yq e ".trash.path" $CONFIG_FILE)
        if [[ -z "$TRASH_DIR" || "$TRASH_DIR" == "null" ]]; then
            TRASH_DIR=$HOME/.trash
        fi
    }

    function clean_trash() {
        dot_trash
        local CLEAN_TIME_DAYS=$(yq e '.trash.clean.time // 30' $CONFIG_FILE)
        local CLEAN_SIZE_MB=$(yq e '.trash.clean.size' $CONFIG_FILE)
        find "$TRASH_DIR" -type f -mtime +$CLEAN_TIME_DAYS -exec rm {} \;
        if [[ -n "$CLEAN_SIZE_MB" && "$CLEAN_SIZE_MB" != "null" ]]; then
            local trash_size
            trash_size=$(du -sm "$TRASH_DIR" | cut -f1)
            while [[ $trash_size -gt $CLEAN_SIZE_MB ]]; do
                find "$TRASH_DIR" -type f -printf '%T+ %p\n' | sort | head -n 50 | cut -d' ' -f2- | xargs rm
                trash_size=$(du -sm "$TRASH_DIR" | cut -f1)
            done  
        fi 
    }

    function dot_del(){
        dot_trash
        TRASH_LOG="$TRASH_DIR/trash.log"
        clean_trash
        if [[ ! -f "$TRASH_LOG" ]]; then
            touch "$TRASH_LOG"
        fi
        if [[ "$1" == "--undo" ]]; then
            local last_entry=$(tail -n 1 "$TRASH_LOG")
            if [[ -n "$last_entry" ]]; then
                local src=$(echo "$last_entry" | cut -d '|' -f1)
                local dest=$(echo "$last_entry" | cut -d '|' -f2)
                mv "$dest" "$src"
                sed -i '$ d' "$TRASH_LOG"
            else
                echo "No deletion to undo."
            fi
        elif [[ -e "$1" ]]; then
            local timestamp=$(date +%s)
            local dest_file="$TRASH_DIR/$(basename "$1").$timestamp"
            mv "$1" "$dest_file"
            echo "$1|$dest_file" >> "$TRASH_LOG"
        fi
    }

    function dot_rm(){
        for i in "$@"; do
            if [[ -e "$i" ]]; then
                rm -rf "$i"
            else
                echo "error: \"$1\" does not exists."
                return
            fi
        done
    }

    function dot_config(){
        if [[ -z "$1" ]]; then
            cd $HOME/.config
        else
            local config_dir=$(yq e ".paths.config.${2}" $CONFIG_FILE)
            if [[ -n "$config_dir" && "$config_dir" != "null" ]]; then
                cd "$config_dir"
            fi
        fi
    }

    function dot_rc(){
        if [[ -z "$1" ]]; then
            dot_open $HOME/.bashrc
        else
            local rc_file=$(yq e ".paths.rc.${2}" $CONFIG_FILE)
            if [[ -n "$rc_file" && "$rc_file" != "null" ]]; then
                dot_open "$rc_file"
            fi
        fi
    }
    function dot_template(){ 
        echo "to be added..."
    }
    

   function dot_alias() {
        if [[ -z "$2" ]]; then
            local alias_input="${1}"
        else
            alias_input=${!#}
        fi
        alias_stack=()
        for ((i = 1; i < $#; i++)); do
            alias_stack+=("${!i}")
        done
        local alias_name="${alias_input%%/*}"
        local remainder_path="${alias_input#*/}"
        if [[ -z "$2" ]]; then
            alias_string=$alias_name
        else
            alias_string="${alias_stack[*]}.$alias_name"
            alias_string=${alias_string// /.}
        fi
        if [[ "$alias_input" == "$alias_name" ]]; then
            remainder_path=""
        fi
        echo $alias_string

        local alias_dir=$(yq eval ".alias.${alias_string}.path" "$CONFIG_FILE")
        local recursive=$(yq eval ".alias.${alias_string}.recursive // false" "$CONFIG_FILE")
        local depth=$(yq eval ".alias.${alias_string}.depth // 0" "$CONFIG_FILE")

        if [[ ! -d "$alias_dir" ]]; then
            echo "Error: Alias or base directory not valid."
            return
        fi

        if [[ -z "$remainder_path" ]]; then
            dot_nav "$alias_dir"
            return
        fi

        local target_path="$alias_dir/$remainder_path"

        if [[ -d "$target_path" ]]; then
            dot_nav "$target_path"
            return
        fi

        if [[ "$recursive" == "true" && "$depth" -ge 0 ]]; then
            local search_path=$(find "$alias_dir" -mindepth 1 -maxdepth "$depth" -type d -path "$target_path*" -print -quit)
            if [[ -d "$search_path" ]]; then
                dot_nav "$search_path"
                return
            fi
        fi

        echo "Error: '$target_path' is not a valid directory."
    }
 
    function dot_preview(){
        if [[ -n $(which fzf) ]]; then
            fzf --preview="cat {}"
        fi
    }

    function dot_source(){
        if [[ -z "$1" ]]; then
            source $HOME/.bashrc
        else
            for i in $@; do
                if [[ -f "$i" ]]; then
                    source $i
                elif [[ -d "$i" ]]; then
                    find $i -type f -exec source {} \;
                else
                    echo "error: \"$i\" does not exists."
                    return 1
                fi
            done 
        fi
    }

    function dot_rename(){
        if [[ -e "$1" ]] && [[ -n "$2" ]]; then
            mv "$1" "$2"
        fi
    }

    function dot_mk(){
        if [[ "$1" == "file" || "$1" == "f" ]]; then
            shift 1
            touch "$@"
        elif [[ "$1" == "dir" || "$1" == "d" ]]; then
            shift 1
            mkdir "$@"
        else
            echo "error: option not defined."
            return 1
        fi
    }

    case "$1" in
        "")
            dot_help 
            ;;
        help|--help)
            dot_help
            ;;
        n|nav)
            shift 1
            dot_nav "$@"
            if [[ "$?" == "1" ]]; then
                return 1
            fi
            ;;
        l|ls)
            shift 1
            dot_ls "$@"
            if [[ "$?" == "1" ]]; then
                return 1
            fi
            ;;
        h|home)
            shift 1
            dot_home "$@"
            if [[ "$?" == "1" ]]; then
                return 1
            fi
            ;;
        o|open)
            shift 1
            dot_open "$@"
            if [[ "$?" == "1" ]]; then
                return 1
            fi
            ;;
        x|exec)
            shift 1
            dot_exec "$@"
            if [[ "$?" == "1" ]]; then
                return 1
            fi
            ;;
        rc)
            shift 1
            dot_rc "$@"
            if [[ "$?" == "1" ]]; then
                return 1
            fi
            ;;
        a|alias)
            shift 1
            dot_alias "$@"
            if [[ "$?" == "1" ]]; then
                return 1
            fi
            ;;
        p|preview)
            shift 1
            dot_preview "$@"
            if [[ "$?" == "1" ]]; then
                return 1
            fi
            ;;
        rn|rename)
            shift 1
            dot_rename "$@"
            if [[ "$?" == "1" ]]; then
                return 1
            fi
            ;;
        rm|remove)
            shift 1
            dot_remove "$@"
            if [[ "$?" == "1" ]]; then
                return 1
            fi
            ;;
        d|del|delete)
            shift 1
            dot_del "$@"
            if [[ "$?" == "1" ]]; then
                return 1
            fi
            ;;
        m|mk|make)
            shift 1
            dot_mk "$@"
            ;;
        mf|mkf|make-file)
            shift 1
            dot_mk file "$@"
            ;;
        md|mkd|make-dir)
            shift 1
            dot_mk dir "$@"
            ;;
        t|template)
            shift 1
            dot_template "$@"
            ;;
        *)
            dot_help
            ;;
    esac
}
